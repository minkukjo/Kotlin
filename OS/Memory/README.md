# 메모리

메모리란 무엇일까요?

여러분들이 알고 계신 8G 램, 16G 램이 바로 메모리 입니다.

RAM은 Random Access Memory의 약자로써 컴퓨터의 주기억 장치입니다.

프로그램은 메모리에 올라가게 되고, 우리는 이것을 프로세스라고 부릅니다.

과거에 비해 현대의 컴퓨터는 메모리가 매우 늘어나서 메모리를 어느정도 희생하고(Space Compexity) 수행 시간을 높이는 (Time Complexity)의 방법을 사용해오고 있습니다.

그러나 여전히 메모리는 비싼 자원이고, OS에서는 이 메모리를 어떻게 효율적으로 관리할 수 있는지를 계속 고민했습니다.

그래서 지금부터 OS가 이 메모리를 어떻게 관리하는지에 대해서 살펴보도록 하겠습니다.

## MMU, TLB

우리가 만든 프로그램은 대게 컴파일 과정을 거쳐 기계어로 바뀌고, 기계어 실행 프로그램이 메모리에 올라가게 됩니다.

MMU는 이러한 CPU가 연산 과정을 거쳐 메모리에 접근하게 도와주는 하드웨어로써 Memory Management Unit의 약자입니다.

현대의 컴퓨터에서는 TLB와 MMU가 CPU 칩안에 포함되어 있습니다.

TLB는 MMU에 내장된 캐시인데요. TLB는 일종의 Page Table Cache라고 생각하시면 되겠습니다.

가상주소가 물리주소로 변경되어야할 때 TLB를 보고 해당 주소가 있다면 (TLB Hit) 물리주소가 반환되고 메모리에 접근합니다.

만약 TLB에 해당 주소가 없다면 메모리에 접근하여 Page Table에서 해당 매핑이 존재하는지 찾습니다.

존재한다면 (Page Table Hit) 이 값을 TLB에 쓰고, 그 주소를 물리 주소로 변환하여 접근합니다.

만약 Page Table에서도 찾지 못한 경우 Disk에서 찾고 찾으면 그 값을 Page Table에 쓰고, TLB에도 쓰고, 물리 주소로 변환한 후 메모리에 접근합니다.

즉, 물리 주소를 알아낼 때 TLB->Page Table->Disk 순으로 찾아보고 접근한다고 보면 되겠습니다.

## Swapping

<img width="483" alt="스크린샷 2019-11-25 오후 9 18 08" src="https://user-images.githubusercontent.com/43809168/69540056-2281da80-0fc9-11ea-90a0-9586e031302c.png">

현재 사용하지 않는 프로세스는 메모리에 올려두지 않고 Backing Store라는 Disk 영역에 저장해둡니다.

사용하지 않는 프로세스를 디스크로 내보내는 것을 **Swap Out**이라고 표현하며, 다시 메모리로 불러오는 것을 **Swap In**이라고 합니다.

이렇게 함으로써 메모리 효율을 높일 수 있습니다.

## 가상 메모리

논리적 주소와 실제 주소를 분리하기 위해 생겨났습니다.

이로 인해 우리는 메모리가 비록 4G이더라도 마치 8G인 것 처럼 사용할 수 있습니다. 마법같은 방법이지요.

가상 메모리는 어려운 개념이 아닙니다. 기존 Physical Memory를 극복하기 위해 Disk 공간을 Memory로 활용하는 방법일 뿐이지요.

결론은 한정된 물리 메모리의 한계를 극복하기 위해 디스크를 이용하여 어플리케이션이 더 많은 메모리를 사용할 수 있게 하는 것이 가상메모리 입니다.

**용어**

```
프레임(Frame) : 물리 메모리를 사용하는 최소 단위
페이지(Page) : 가상 메모리를 사용하는 최소 단위
```

일반적으로 프레임과 페이지는 같은 크기로 두는 것을 원칙으로 합니다.

페이지는 프로세스의 구성요소 입니다.

**Page**

Page는 **가상 메모리를 사용하는 최소 크기 단위**입니다.

일반적으로 4KB의 크기를 갖습니다.

이러한 Page라는 개념을 왜 도입했을까요?

만약, 최소 크기 단위가 없다면 각기 다른 크기의 데이터들이 메모리에 올라가게 될 것이고, 메모리 공간에 파편화 현상이 발생하게 됩니다.

메모리 공간이 남아있음에도 불구하고 무분별한 배치로 인해 메모리에 로드할 수 없는 현상이 발생할 수도 있습니다.

이를 막기 위해 운영체제가 만든 것이 Page라는 최소 크기 단위 입니다.

**Segmenation**

세그멘테이션 기법이란 서로 다른 크기의 메모리를 논리적인 블록 단위인 Segment로 분할하고 메모리를 할당하여 물리 주소를 논리 주소로 변경하는 것을 의미합니다.

<img width="376" alt="스크린샷 2019-11-25 오후 10 16 06" src="https://user-images.githubusercontent.com/43809168/69543550-35001200-0fd1-11ea-9f19-78f67c848fd8.png">

각 영역 별로 기능,권한,필요한 공간의 크기가 모두 다르기 때문에 세그멘테이션 기술로 분할하여 효율적으로 메모리를 관리하게 합니다.

**Paging**

Paging 기법은 말그대로 가상 메모리를 Page 단위로 쪼개서 관리하는 것을 의미합니다.

페이징 기법이 적용된 시스템에서 가상주소는 p(페이지 번호),d(offset)으로 이루어져 있습니다. 이 정보는 Page Table Entry라는 곳에 존재하며 p를 이용해 프레임 번호를 알아내고(p`) 거기에 offset 더해 물리 주소를 구합니다.

물리주소 = p`(Frame Number) + d(offset)

**Demanding-Page**

Demanding-Page는 실제 필요한 Page만 물리 메모리에 가져오는 방식을 의미합니다.

Page에 접근하기 위해서는 가상 주소를 보고 대응하는 물리 주소로 찾아가야 하는데 이때 필요한 것이 **Page Table** 입니다.

Page Table은 가상 메모리 주소와 물리 메모리 주소가 1:1로 매핑되어 있는 도표입니다.

Page Table은 프로세스 마다 하나씩 존재하며, 메인 메모리(RAM)에 상주하고 있습니다.

OS는 이 Page Table을 보고 가상 메모리 주소에 매핑된 물리 메모리 주소에 접근합니다.

그런데 만약 물리 메모리 주소에 페이지가 없다면? 이런 상황을 **Page Fault**라고 합니다.

이때 OS는 다음과 같은 절차를 거칩니다.

```
1. CPU가 물리 메모리에 페이지가 없는 경우 trap을 발생하여 OS에게 알린다.

2. 운영체제는 CPU를 잠시 멈춘다.

3. 운영체제는 Page Table을 보고 가상 메모리에 페이지가 존재하는지 확인하고, 없는 경우 프로세스를 중단한다.

4. 메모리에서 빈 Frame을 찾는다.

5. 비어있는 Frame에 페이지를 로드하고, 페이지 테이블을 최신화 한다.

6. 중단된 CPU를 다시 시작한다.
```

이 과정을 통해 Page Fault를 극복합니다.

문제는, 4번에서 만약 빈 Frame을 찾지 못하는 경우는 어떻게 될까요?

이때 메모리에 올라와 있는 Frame 중 하나를 골라 page-out 시키고, 그 Frame을 사용하게 합니다.

이러한 Victim Frame을 고르는 알고리즘은 여러가지가 있으나

가장 유명한 LRU 방식만을 소개해드리겠습니다.

**LRU**는 Least Recent Used의 약자로써 가장 오랫동안 사용되지 않은 Frame은 앞으로도 그럴 것이다! 라는 기대로 Page-Out하는 방식입니다.






## Reference

http://egloos.zum.com/sweeper/v/2988689
https://preamtree.tistory.com/21
https://m.blog.naver.com/s2kiess/220149980093