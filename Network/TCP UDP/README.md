# TCP UDP

4계층 Transport Layer에 해당하는 통신 프로토콜에는 TCP와 UDP가 있다.

TCP와 UDP는 신뢰성과 신속성으로 분류할 수 있다.

데이터를 주고 받는 것이 중요하다면 **TCP**를,

데이터를 주고 받는 것 보다, 빠르게 보내는 것이 중요하다면 **UDP**를 사용하면 된다.

지금부터 각각의 프로토콜에 대해서 좀 더 자세히 알아보자

## TCP

TCP의 특징은 다음과 같다.

- 연결 지향
- 신뢰성있는 데이터 전송
- 흐름제어
- 혼잡 제어
- 오류 제어

지금부터 하나씩 알아보자

### 연결 지향

TCP는 연결지향 프로토콜이다.

이 말은 프로토콜에 의해 연속적인 패킷의 상태 정보를 확인하고 유지하는 것을 기본으로 한다는 것을 알 수 있다.

따라서, 장치간의 **연결**에 관한 세션을 수립하는 과정이 매우 중요하다.

이 과정을 우리는 **TCP-3-way-handshake**라고 부른다.

![99087C405C18E3CD28](https://user-images.githubusercontent.com/43809168/72984139-51c89280-3e26-11ea-9d2c-ca8633cccbed.png)

마치 악수를 하듯이 세번의 과정을 거쳐서 연결을 수립할 수 있다.

1. 클라이언트는 서버에게 접속 요청 메세지 SYN을 전송하고 SYN_SENT 상태가 된다. a를 보냈다.

2. 서버는 SYN 요청을 받고 클라이언트에게 요청 수락 (SYN + ACK) 하고 SYN_RECEIVED 상태가 된다. SYN(b) + ACK(a+1)를 응답한다.

3. 클라이언트는 서버에게 수락 확인 ACK(b+1)을 보내고 서버는 ESTABLESHED 상태가 된다.

이러한 3-way-handShake와 과정을 거쳐서 신뢰성 있는 연결을 보장할 수 있게 되는 것이다.

3-way-handShake와 마찬가지로, 접속 상태를 **해제**하기 위한 과정 또한 필요한데, 

이를 **4-way-handshake**라고 부른다.

![스크린샷 2020-01-23 오후 9 25 37](https://user-images.githubusercontent.com/43809168/72984379-ea5f1280-3e26-11ea-9861-220997955356.png)

총 4번의 과정을 거친다.

1. 클라이언트가 FIN 요청을 보낸다.

2. 서버가 응답(ACK) 을 보낸다.

3. 잠시 후 서버는 close를 하고 FIN을 보낸다.

4. 클라이언트는 ACK를 서버에게 보내고, 서버는 CLOSED 상태가 된다.

5. 이 후 클라이언트는 어느정도 시간이 흐른 뒤에 CLOSED 상태로 바뀐다. 기다리는 이유는 혹시나 서버에서 미처 보냈는데 도착하지 못한 패킷이 있을 지 모르기 때문에 그것들을 받아주기 위해서 ACK를 보내고 나서도 조금 더 기다렸다가 CLOSE 상태가 된다.

### 신뢰성 있는 데이터 전송

신뢰성 있는 데이터를 전송하기 위해 조금은 복잡한 일련의 프로토콜을 소개한다.

#### RDT 1.0 (Reliable Data Transfer)

![스크린샷 2020-01-23 오후 9 35 40](https://user-images.githubusercontent.com/43809168/72985025-66a62580-3e28-11ea-999a-2117171d97fa.png)

이 프로토콜은 단순하다.

하위 채널이 완전히 신뢰적인 경우를 고려하는 것이다.

RDT 1.0은 송신자와 수신자에 대한 유한 상태머신이다.

a는 송신자, b는 수신자의 동작을 정의한다.

시나리오는 간단하다.

1. 송신측에서 패킷을 만들고 패킷을 수신자에게 보냄

2. 수신자는 패킷을 받으면 데이터를 추출하고 데이터를 상위 계층에 전달함.

#### RDT 2.0

비트 오류가 있는 채널 상에서의 신뢰적 데이터 전송에 대한 모델이다.

RDT 2.0에서는 데이터 채널의 비트 오류를 확인하기 위해 긍정 확인 응답과 부정 응답 확인을 사용한다.

이러한 제어 메세지는 정확하게 수신되었는지 또는 잘못 수신되어 반복이 필요한지를 수신자가 송신자에게 알려줄 수 있게 한다.

컴퓨터 네트워크에서는 이러한 재전송 기반 데이터 전송 프로토콜을 **자동 재전송 요구 프로토콜 Automatic Repeat reQuest**라고 하며 줄여서 ARQ라고 부른다.

![스크린샷 2020-01-23 오후 9 42 41](https://user-images.githubusercontent.com/43809168/72985427-4c207c00-3e29-11ea-807b-d70bf573abff.png)

2.0에서는 송신자 측이 2개의 FSM을 갖는다.

송신자는 상위 계층으로 부터 데이터가 전달되기를 기다린다.

rdt_send()가 호출되면 송신자는 패킷 CheckSum과 함께 전송될 데이터를 포함하는 패킷(sndpkt)을 생성하고, 그 패킷을 udt_send 동작을 통해 전송한다.

그 후 송신자 프로토콜은 수신자로 부터 ACK or NAK 응답을 기다린다.

만약 ACK가 수신된다면 마지막에 보낸 패킷이 정확하게 수신되었다는 뜻이고 NAK가 수신되면 프로토콜은 마지막 패킷을 재전송하고 재전송된 패킷에 ACK or NAK를 기다린다.

단, 이때 ACK 또는 NAK를 기다리는 수신 대기상태에서는 상위 계층으로 부터 더 이상 데이터를 받을 수 없다.

즉 rdt_send()가 재전송의 응답을 기다리는 동안에 발생하지 않는다.

그래서 rdt2.0 프로토콜은 전송 후 대기(Stop-and-Wait) 프로토콜로 알려져 있다.

rdt2.0은 비트 오류를 검출하고 재전송하여 완벽한 것 같지만 치명적 약점이 존재한다.

바로 ACK or NAK가 손상될 수 있다는 점이다.

이러한 오류를 검출하기 위해 ACK와 NAK에 대한 CheckSum bit를 추가할 필요가 생긴다.

#### RDT 3.0

3.0는 두가지 문제를 해결하고자 했다.

1. 어떻게 패킷 손실을 검출할 것인가
2. 손실이 발생했을 때 어떤 행동을 취할 것인가

지금부터 3.0은 이를 어떻게 극복하였는지 알아보자

패킷 손실 검출을 위해서는 새로운 매커니즘을 추가해야 했다.

이를 위해 sender는 합리적인 시간만큼 ACK를 기다린다.

만약 기다렸는데도 ACK가 안온다면? 재전송을 한다.

만약 RTT가 합리적인 시간보다 길어진 경우라면?

즉, ACK가 지연된 것이라면 Receiver는 중복된 Packet을 받게 된다.

하지만 이 중복 데이터는 Sequence Number를 이용하면 중복데이터 처리가 가능하며 이는 rdt.0을 발전시킨 rdt.2에서 이미 구현하였다.

그래서 이러한 재전송을 하기 위해 **Countdown Timer**라는 개념을 만들었다.

송신자는 다음과 같이 동작한다.

1. 모든 패킷은 송신된 시간에 타이머를 시작한다.

2. 타이머 인터럽트에 반응하고 인터럽트 루틴을 처리한다.

3. 타이머를 멈춘다.

![스크린샷 2020-01-23 오후 9 56 35](https://user-images.githubusercontent.com/43809168/72986291-3e6bf600-3e2b-11ea-826e-7b1e1628319a.png)

### 흐름 제어

송신측과 수신측이 데이터를 주고 받을 때, 여러가지 요인으로 둘의 처리속도가 달라질 수 있다.

이 때 데이터를 받는 수신측의 처리 속도가 송신 측보다 빠른 경우는 크게 문제될 일이 없다.

그러나 반대로 송신측의 처리 속도보다 수신측의 전송 속도가 빠르다면, 수신측의 버퍼가 가득찬 상황에서 데이터는 폐기처분된다.

송신측에서 이를 알고 다시 데이터를 보내주긴 하겠지만, 네트워크 환경에서 이러한 과정은 가능하면 줄일 수 있는게 좋다.

이러한 수신측의 데이터 처리속도를 파악해 얼마나 빠르게, 많은 데이터를 처리할지 결정해야하는데 이것이 바로 TCP의 흐름 제어인 것이다.

흐름 제어 방법에는 Stop-and-Wait와 Sliding Window 두가지 방식이 존재한다.

#### Stop and Wait

![stop-and-wait](https://user-images.githubusercontent.com/43809168/72992472-200bf780-3e37-11ea-84d5-efbe3c91cdbd.png)

어찌 보면 가장 단순한 방법이다.

이름 그대로 데이터를 주고, ACK를 받을 때 까지 기다리는 방식이다.

문제는 이러한 경우 방식이 간단한 만큼 비효율 적이다.

왜냐하면 송신측은 자신이 직접 데이터를 보내봐야 이 데이터를 수신측이 처리할 수 있는지 알 수 있기 때문이다.

그래서 이 방식은 잘 사용을 안한다.

#### Sliding Window

![스크린샷 2020-01-23 오후 11 24 21](https://user-images.githubusercontent.com/43809168/72992670-8264f800-3e37-11ea-806e-30b9337c438c.png)

오늘날의 TCP는 대부분 흐름제어 방식에 Sliding Window 기법을 사용한다.

슬라이딩 윈도우는 수신 측이 한 번에 처리할 수 있는 데이터를 정해놓고, 그때 그때 수신측의 데이터 처리 상황을 송신측에 알려줘서 데이터의 흐름을 제어하는 방식이다.

둘의 가장 큰 차이점은 **수신(Sender)측이 송신(Receiver)측에서 얼마만큼의 데이터를 처리할 수 있는지를 이미 알고 있다는 점**이다.

실제 환경에서 TCP의 최대 윈도우 크기는 65,535 bytes 이고 WSCALE 옵션을 최대로 적용하면 1GB까지도 가능하다고 하니,

연속적으로 한번에 보내는 데이터도 이정도 단위로 보내고 받는다면 굉장히 좋은 효율을 뽑아낼 수 있다.

이론적으로는 수신측의 ACK 응답 없이도 최대 1GB를 연속적으로 전송할 수 있다는 의미이기도 하다.

### 혼잡 제어

송신측의 데이터는 지역망이나 인터넷으로 대형 네트워크를 통해 전달된다.

만약 하나의 라우터에 대량의 데이터가 몰린다면 어떻게 될까?

자신에게 온 모든 데이터를 처리 할 수 없을 것이다.

이런 경우 호스트들은 다시 재전송을 할 것이고, 이는 혼잡을 가중시켜 데이터 손실을 유발하게 될 것이다.

TCP에서는 네트워크 내에 패킷의 수가 과도하게 증가하는 혼잡현상을 방지하거나 제어하는 기능을 갖고 있다.

앞서 봤던 흐름 제어를 할때 송신측의 윈도우 크기는 수신측이 보내준 윈도우 크기와 네트워크 상황을 고려해 정해진다고 하였다.

송신 측은 자신의 최종 윈도우 크기를 정할 때 수신 측이 보내준 윈도우 크기인 **수신자 윈도우 RWND**와 네트워크 상황을 고려해 정한 윈도우 크기인 **혼잡 윈도우 CWND** 중 더 작은 값을 선택한다.

여기서는 혼잡 회피를 하기 위한 방법과 혼잡 제어 정책에 어떤 것이 있는지 살펴보도록 하자.

#### 혼잡 회피

##### AIMD

Additive Increase / Multicative Decrease 방식은 우리 말로 직역하면 합 증가 / 곱 감소 방식이라는 뜻이다.

즉 네트워크가 충분히 혼잡하지 않을 때는 혼잡 윈도우의 크기를 1씩 증가시키다가 줄어들 때는 1/2로 줄어들게 하는 것이다.

이름 그대로 **합 증가 / 곱 감소**인 것이다.

이러한 방식은 늘어날때는 선형적으로 늘어나다가, 줄어들 때는 반으로 확 줄어들 것이다.

![스크린샷 2020-01-23 오후 11 41 08](https://user-images.githubusercontent.com/43809168/72994087-da046300-3e39-11ea-823a-06a14a0f822e.png)

그래서 AIMD는 위와 같은 그래프 형태를 보인다.

그러나 AIMD의 문제점은 네트워크 대역이 펑펑 남아도는 상황에서도 윈도우 크기를 너무 조금씩 늘리면서 접근한다는 것이다.

그래서 AIMD 방식은 네트워크의 모든 대역을 활용하여 제대로된 속도로 통신하기 까지 시간이 걸린다.

##### Slow Start

앞서 본것처럼 AIMD는 제대로된 속도가 나오기까지 시간이 걸린다는 단점이 있었다.

요즘에는 네트워크 대역폭이 워낙 넓고 통신 인프라가 좋다보니 예전에 비해 네트워크 혼잡이 발생하는 빈도가 많이 줄어서 AIMD의 단점이 더욱 부각되게 되었다.

반면, 지금부터 알아볼 Slow Start 방식은 AIMD와 그 원리는 비슷하지만 윈도우 크기를 증가시킬때는 지수로 증가시키다가 혼잡한 상황에선 윈도우 크기를 1로 줄여버리는 방식이다.

최근 TCP에서 사용하고 있는 Tahoe나 Reno같은 정책들은 AIMD와 Slow Start를 적절히 섞어서 사용하되, 네트워크 혼잡 상황이 발생했을 때 어떻게 처리하는지에 따라 나눠지게 된다.

### 혼잡 제어 정책

방금 까지는 혼잡 회피 방법에 대해서 알아보았다면, 지금부터는 혼잡 제어 정책이라는 것을 알아보자.

혼잡 제어 정책이란 **혼잡이 발생하면 윈도우 크기를 크게 줄이거나, 혹은 증가시키지 않으며 혼잡을 회피한다**라는 혼잡 회피 방식의 전제를 깔고 있다.

그 중 여러 혼잡 제어 정책이 있지만 Tahoe와 Reno에 대해서 알아보자.

#### 3 ACK Duplicated, Timeout

우선 두 방식 모두 3 ACK Duplicated와 Timeout이라는 두가지 시나리오가 발생하면 윈도우 크기를 줄이는 방식을 사용하고 있다.

이 두 상황은 혼잡 제어 정책들이 혼잡 발생을 감지하는 상황을 나타낸다.

타임 아웃은 말 그대로 여러가지 요인에 의해 송신측이 보낸 데이터 자체가 유실되거나 수신측이 응답으로 보낸 ACK가 유실되는 경우를 의미한다.

![스크린샷 2020-01-23 오후 11 53 07](https://user-images.githubusercontent.com/43809168/72995017-872bab00-3e3b-11ea-80ea-cf9c76d4abff.png)

3 ACk Duplicated 의미 그대로 송신 측이 3번 이상 중복된 승인 번호를 받은 상황을 의미한다.

동일한 ACK를 3번 받는다는 것은 수신측에서 특정 시퀀스 번호 이후의 데이터를 제대로 처리하지 못한 상황이라고 할 수 있겠다.

패킷 전송 방식을 사용하는 TCP의 특성 상 수신측이 받는 패킷의 순서가 늘 순서대로 받을 수는 없으므로 한 두개의 중복 승인 번호가 발생했다고 네트워크가 혼잡하다고 판단하지는 않는다.

TCP는 현재까지 누적된 정상 데이터 중 가장 마지막 데이터에 대한 승인 번호를 보내주는 누적 승인 방식을 사용하기 때문에,

송신측이 같은 승인 번호를 계속해서 받는다면 해당 데이터까지는 제대로 받았는데, 그 이후부터는 문제가 있음을 알 수 있다.

#### Slow Start 임계점(ssthresh)

Slow Start 임계점이란 이 지점까지만 Slow Start를 사용하겠다는 것을 의미한다.

즉, Tahoe나 Reno는 특정 지점까지만 Slow Start로 윈도우 크기를 증가시키는데, 그 이유가 지수승으로 너무 가파르게 늘어나게 되면 제어가 힘들어지고, 네트워크 혼잡이 예상되는 상황에서 빠르게 값을 증가시키는 것 보단 조금씩 증가시키는 편이 안전하기 때문이다.

그래서 임계점을 설정하고 임계점을 넘어갈대는 AIMD 방식을 사용하여 선형적으로 윈도우 크기를 증가시키게 한다.

이 임계점을 칭하는 단어가 바로 ssthresh인 것이다.

#### TCP Tahoe

TCP Tahoe는 Slow Start를 사용한 혼잡 제어 정책의 초기 버전으로, Fast Transmit 기법이 처음으로 도입된 방식이다.

3번의 중복 승인으로 인해 송신 측이 해당 승인 번호에 해당하는 데이터를 전송하고 나면 수신측은 Go Back N이나 Selective Repeat와 같은 오류 제어 방식에 따라 다음에 어떤 패킷부터 보내줘야하는지 알려줄 것 이다.

이때 송신 측이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 전송할 수 있는 방식이 Fast Transmit이다.

Tahoe는 임계점까지는 Slow Start 방식을 사용하다가, 그 이후부터는 AIMD를 사용하는 방식이다.

그러나 Tahoe 방식은 혼잡 상황이 발생했을때 윈도우 크기가 1로 줄어들기 때문에 1부터 다시 증가시키는 것은 낭비일 수 있다.

그래서 나온 방법이 Reno 방식이다.

#### TCP Reno

Tahoe 정책 이후에 나온 정책으로 Slow Start로 시작하여 임계점을 넘어서면 합증가로 변경하는 방식이다.

Tahoe와 대비되는 점은 3 ACK Duplicated와 Timeout을 구분한다는 것이다.

Reno는 3개의 중복 ACK가 발생했을 때 혼잡 윈도우의 크기를 1로 줄이는 것이 아닌, 반으로 줄인 후 합증가를 수행한다.

이 방식은 1로 줄이는 Tahoe에 비해 원래 윈도우 크기에 빠르게 도달할 수 있기 때문에 빠른 회복(Fast Recovery)이라고도 불리운다.

그러나 Timeout이 발생해 데이터가 손실되면 윈도우 크기를 1로 줄여버리고, Slow Start를 진행하고 ssthresh를 변경하지 않는다.

3 ACK Duplicated와 Timeout이 발생한 상황을 구분하여 다르게 대처를 한다는 점에서 Tahoe와 대비되는 점이다.

## 오류 제어

TCP는 기본적으로 ARQ(Automatic Repeat Request), 재전송 기반 오류제어를 사용한다.

즉 통신 중에 오류가 발생하면 송신 측이 수신 측에 다시 데이터를 전송하는 방식이다.

하지만 재전송은 이미 했던 작업을 다시 해야하는 비효율적인 작업이기 때문에 이 재전송 과정을 최대한 줄일 수 있는 여러가지 방법을 사용하게 된다.

그러면 송,수신측은 어떻게 오류가 발생했음을 파악할 수 있을까?

TCP를 사용하는 송수신측이 오류를 파악하는 방법은 크게 두가지다.

**첫번째**

송수신측이 보낸 데이터를 받지 못해 타임아웃이 발생한 경우이다.

타임아웃은 말 그대로 송신측이 보낸 데이터가 중간에 유실되어, 수신측이 아예 데이터를 받지 못하는 경우거나 수신측은 제대로 응답했는데 ACK 패킷이 유실되는 경우에 발생한다.

**두번째**

송신 측이 중복된 ACK를 받는 경우 오류라고 판별한다.

이 때 같은 ACK를 3번 받았을 때 일반적으로 에러라고 판단한다.

### Stop And Wait

흐름제어때 살펴본 방식인 Stop And Wait 방식을 오류 제어에서도 사용할 수 있다.


![스크린샷 2020-01-24 오전 12 27 40](https://user-images.githubusercontent.com/43809168/72997892-57cb6d00-3e40-11ea-8dc7-3af4c786b798.png)

만약 Stop And Wait 방식을 이용하면 흐름제어 뿐만 아니라 오류제어 또한 가능하다.

그러나 오류 제어에서 Stop And Wait 방식을 사용하면 흐름제어에서 슬라이딩 윈도우를 쓰는 의미를 잃어버리게 된다.

### Go Back N

데이터를 연속적으로 보내다가 그 중 어느 데이터부터 오류가 발생했는지를 검사하는 방법이다.

![스크린샷 2020-01-24 오전 12 27 16](https://user-images.githubusercontent.com/43809168/72997856-497d5100-3e40-11ea-9cbf-1b7330c90405.png)

Go Back N 방식은 데이터를 연속으로 보내게 한 뒤 한개의 ACK나 NACK만을 사용하여 처리 상황을 파악할 수 있으므로 연속적인 데이터를 보내는 슬라이딩 윈도우와 궁합이 좋다고 할 수 있겠다.

위의 시나리오에서는 4번 데이터부터 에러가 발생함을 감지하고 4번부터 다시 보내라! 라고 하고 있다.

이때 Go Back N에서는 4번 데이터에서 에러가 발생하면 4번 이후 받은 수신측이 갖고 있는 모든 데이터를 폐기하고 송신측에 NACK를 보내고, 그 이후부터 다시 받는 방식이다.

### Selective Repeat

![스크린샷 2020-01-24 오전 12 29 54](https://user-images.githubusercontent.com/43809168/72998096-a842ca80-3e40-11ea-9cf3-aee8adcc30b2.png)

이름 그대로 선택적 재전송을 의미한다.

Go Back N도 충분히 효율적인 방법이지만, 에러가 발생하면 그 이후부터 다시 재전송을 하는 비효율이 여전히 존재한다.

그래서 **에러난 부분만 다시 재전송해줘**라는 방식이 Selective Repeat 방식이라고 볼 수 있겠다.

문제는 수신측 버퍼에 쌓이는 데이터가 연속적이지 않게 된다는 단점이 있다.

왜냐하면 중간에 폐기 처분된 값을 제외하고 순차적으로 데이터가 존재하게 될 것이기 때문에 중간에 유실된 값을 송신측이 재전송하게 되면 수신측은 이 데이터를 버퍼 중간에 끼워넣어 데이터를 정렬해야하는 상황이 발생하는 것이다.

결국 재전송을 하는 과정이 빠진 대신 재정렬이라는 과정이 추가되었기 때문에 재전송이 좀 더 나은 경우라면 Go Back N을 재정렬이 좀 더 이득인 상황이라면 Selective Repeat 방식을 사용하는 것이 맞겠다.

## UDP

TCP와 같은 4계층 Transport Layer의 통신 프로토콜인 UDP에 대해서 알아보자.

TCP가 신뢰성에 주안점을 둔 프로토콜이었다면 UDP는 속도에 주안점을 둔 프로토콜이다.

TCP는 기본적으로 ARQ(Automatic Repeat Request)를 사용하고 있기 때문에 데이터를 주고받는데에 신뢰성을 보장해야하므로 느릴 수 밖에 없다.

그러나 이러한 TCP 프로토콜은 데이터 송수신에 반드시 데이터가 전송되어야 하는 경우가 아닌, 실시간 스트리밍 서비스 같은 서비스에서는 이러한 매커니즘이 오히려 방해가 되었다.

또한 TCP에는 혼잡 제어를 위해 보내는 양도 조절하기 때문에 영상 데이터의 퀄리티 또한 일정하지 못했다.

때문에 이러한 **유실되어도 괜찮은** 서비스에서 사용하는 프로토콜이 UDP라고 하겠다.

UDP는 TCP에서 수행하는 모든 신뢰성 검사 기능이 없다고 보면 된다.

데이터를 그냥 보내기만 할 뿐이고, 상대방이 데이터를 제대로 받았는지에 대해서도 관심이 없다.

이러한 신뢰성을 검증하는 단계가 없기 때문에 UDP는 비연결형이라고 부른다.

최근 HTTP3가 UDP 프로토콜을 사용하면서 화제를 일으킨적이 있었다.

UDP도 사실은 얼마든지 신뢰성있는 네트워크를 구축하는 것이 가능하다.

TCP에서 하는 신뢰성 작업을 직접 프로그래밍하여 구현하면 되기 때문이다.

그래서 HTTP3에서 UDP를 고른 것은, 정확히 말하자면 구글이 개발한 QUIC 프로토콜 때문이다. QUIC은 TCP의 핸드 쉐이크 과정을 최적화 하기 위해 설계되었고, UDP를 사용함으로써 이를 실현할 수 있엇다.

다시 말하자면 UDP는 마치 도화지와 같은 프로토콜이기 때문에 어플리케이션에서 어떻게 구현하느냐에 따라 TCP와 비슷한 수준의 기능을 갖는것도 가능하다는 의미이다.

## 결론

OSI 4계층의 Transport Layer의 프로토콜에 해당하는 TCP와 UDP에 대해 알아보았다.

아무래도 UDP 보다는 현재 우리가 사용하고 있는 웹 프로토콜인 HTTP/2가 TCP이다 보니 TCP에 조금 더 자세하게 알아보았다.

물론 이번에 등장한 HTTP/3가 UDP 프로토콜을 기반으로 하긴 하지만 이 역시도 TCP가 기본적으로 수행하는 핸드 쉐이크 과정이나 전송 속도를 개선하기 위해 QUIC 프로토콜에서 UDP를 사용해 개선한 것일 뿐이지 기본적인 이념은 같다고 볼 수 있다.

기존의 HTTP와 TCP가 가진 문제를 타결하기 위한 새로운 시도이고, 아마도 근 미래에 HTTP는 UDP로 기억되는 날도 올 것이다.

그 미래를 위해 TCP든 UDP든 열심히 기초 컴퓨터 공학 지식을 공부하여 다가올 미래를 대비하자.

## Reference

https://sjlim5092.tistory.com/entry/tcp-3-way-handshake-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC

https://lkhlkh23.tistory.com/130?category=833712

https://rain-bow.tistory.com/entry/%EC%8B%A0%EB%A2%B0%EC%A0%81%EC%9D%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1-RDT-102030

https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/

https://www.slideshare.net/GondweBenard/module15~~~~