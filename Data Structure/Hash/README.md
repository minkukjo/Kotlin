# Hash Table

해쉬 테이블이란 검색과 저장이 매우 빠른 자료구조이다.

무려 검색, 저장의 시간 복잡도가 O(1)이다.

해쉬 테이블은 Key와 Value의 쌍으로 이루어져있다.

Key는 중복이 없는 고유한 값으로 Value와 1:1 매핑된다.

Hash Fuction은 이 Key를 Hash로 바꿔준다.

Hash Fuction을 거친 key 값은 해쉬 테이블에 매핑된다.

이러한 해쉬 테이블의 저장소를 bucket이라고 표현한다.

그러나 아무리 완벽한 Hash Fuction이라고 할지라도, 같은 값을 만들어낼 위험은 항상 존재한다.

Key가 다르더라도, 같은 Hash로 변하는 문제가 발생할 수 있다.

이러한 현상을 Hash Collision이라고 한다.

Hash Collision을 극복하는 두가지 방법이 있다.

**Open Addressing**과 **Separate Chaining** 방식이다.

## Open Addressing

개방 주소법이라고도 불리우는 이 방법은 비어있는 해시를 발견할 때 까지 찾아가는 방법이다.

이 개방 주소법에는 총 세가지 방법이 있다.

1. Linear Probing

말 그대로 선형적으로 탐색한다는 의미이다. +1씩 증가시키면서 비어 있는 해시에 데이터를 저장한다.

2. Quadratic Probing

충돌이 일어난 해시에 제곱을 하여 빈 해시를 찾아간다.

3. Double Hashing

이중 해시라고 하며 다른 해시 함수를 한번 더 적용한 해시값으로 빈 해시를 찾아간다.

결과적으로 개방 주소법은 비어있는 해시를 발견할 때 까지 찾아가는 방법이다.


시간 복잡도는 버킷의 길이를 n, 키의 수를 m이라고 했을 때 m/n이 된다. 이때 m/n의 값은 1보다 작거나 같다.

왜냐하면 저장소 개당 1개의 값만 가지기 때문이다.

삽입/삭제/검색의 경우 모두 최상의 경우 O(1)이며 전체 버킷의 전체 사이즈 만큼 반복될 경우 O(n)이 된다.

그래서 개방 주소법에서는 저장소가 어느정도 채워지면 사이즈를 늘려주는 것이 필요하다.

## Spearate Chaining

충돌이 발생할 경우 연결리스트로 이어주는 방식이다.

충돌이 일어날 때 마다 하나의 bucket에 여러 체인이 달릴 수 있다.

충돌이 발생할 경우 연결리스트의 Head에 자료를 저장할 경우 O(1)의 시간복잡도를 가질 수 있다.

Tail에 연결하는 경우라면 O(m/n), 최악의 경우 모든 연결리스트를 지나야 하기 때문에 O(n)이 될 수 있다.

삭제와 검색은 시간복잡도에서 비교적 비슷한 개념을 공유한다.

연결리스틀 차례로 찾아봐야하므로 O(m/n), 최악의 경우 O(n)이 걸린다.

자바8에서는 이를 극복하기 위해 연결리스트의 크기가 8이상이 되면 자료구조를 RB Tree로 변경하여 검색시간을 O(log m/n)으로 줄였다.

## 해시 테이블의 단점

- Hash Fuction의 의존도가 높다
- 공간 효율성이 떨어진다.
- 순서가 있는 배열에는 어울리지 않는다.

## Reference

https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o