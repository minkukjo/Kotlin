# 정규화(Normalization)란?

데이터베이스의 설계를 재구성하는 기술입니다.

정규화를 통해 불필요한 데이터를 없앨 수 있고 데이터의 중복을 최소화 할 수 있습니다.

또한 삽입/삭제/갱신 시 발생할 수 있는 각종 이상 현상을 방지할 수 있습니다.

데이터베이스 정규화의 목적은 두가지 입니다.

1. 불필요한 데이터를 제거한다.
2. 데이터 저장을 ```논리적```으로 한다.

<img width="870" alt="1" src="https://user-images.githubusercontent.com/43809168/69430063-4d292480-0d78-11ea-905e-5f3fa01957e6.png">

위 테이블은 정규화가 되지 않은 과목 수강 신청에 대한 테이블입니다.

현재 S_Name에 Adam이 두번 들어가 있는 것을 볼 수 있습니다.

위 테이블에 DML 문제점에 대해서 몇가지 짚어보도록 하겠습니다.

1. Update : Adam의 주소가 Update될 경우 Adam에 해당하는 모든 데이터를 업데이트 해주어야 한다.
2. Insert : 만약 어떤 학생도 수강하지 않는다면 Subject_opted에 Null이 들어가게 된다.
3. Delete : Alex가 과목을 수강 취소하면 Alex에 대한 레코드가 지워진다.

위와 같이 정규화가 제대로 되지 않은 경우 갱신/삽입/삭제에 이상이 발생할 수 있다는 것을 알 수 있습니다.

때문에 지금부터 1,2,3차 정규화를 통해 위 테이블을 정규화 해보도록 하겠습니다.

일반적으로 3차 정규화까지 진행되면 ```정규화가 완료되었다.``` 라고 말합니다.

## 1차 정규화 (1NF, First Normal Form)

1차 정규화에서는 각 Row마다 Column이 하나의 값을 가져야 만족할 수 있습니다.

<img width="745" alt="스크린샷 2019-11-24 오후 9 46 09" src="https://user-images.githubusercontent.com/43809168/69494858-e6d10d00-0f03-11ea-8fa8-01fdd1ffcd62.png">

위의 테이블에서 속성이 여러개의 값을 갖고 있는 것을 볼 수 있습니다.

1차 정규화를 진행하게 될 경우 아래와 같이 바뀌게 됩니다.

<img width="758" alt="스크린샷 2019-11-24 오후 9 46 12" src="https://user-images.githubusercontent.com/43809168/69494859-e769a380-0f03-11ea-9d51-fd386ca81980.png">

모든 속성이 단일 값을 갖고 있습니다.

이것을 1차 정규화가 완료되었다 라고 표현합니다.

하지만 아직도 삽입/갱신/삭제에 대한 문제는 여전히 남아있습니다.


## 2차 정규화 (2NF, Second Normal Form)

2차 정규화부터는 본격적인 정규화의 시작이라고 볼 수 있습니다.

```2차 정규화가 되기 위해서는 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되야 합니다. 또한 1차 정규화가 완료된 상태여야 합니다.```

완전 함수 종속이란 기본키가 아닌 다른 속성들이 기본키에 ```종속```됨을 의미합니다.

쉽게 얘기하면 기본키가 아닌 속성의 값들이 기본키의 값을 알아야만 알 수 있어야 합니다.

이해하기 쉽게 아래의 테이블을 보면서 이야기하겠습니다.

<img width="762" alt="스크린샷 2019-11-24 오후 9 46 49" src="https://user-images.githubusercontent.com/43809168/69494865-fc463700-0f03-11ea-9687-d6574a50973b.png">

현재 테이블의 함수적 종속성은 다음과 같습니다.

```
{학번 + 과목코드} -> 성적
{학번 + 과목코드} -> 학부
{학번 + 과목코드} -> 등록금
학번 -> 학부
학번 -> 등록금
학부 -> 등록금
```

현재 학번 -> 학부와 학번 -> 등록금에 부분 함수 종속성이 발견되었습니다.

왜 그럴까요?

위 테이블의 기본키는 학번과 과목 코드입니다.

그러나 학번만 알아도 학부를 알아낼 수 있고,

학번만 알아도 등록금을 알아낼 수 있습니다.

이것을 부분 함수 종속성이라고 표현하며, 2차 정규화를 진행하여 테이블을 두개로 나누어 줍니다.

<center>학생</center>
<img width="772" alt="스크린샷 2019-11-24 오후 9 46 54" src="https://user-images.githubusercontent.com/43809168/69494866-fc463700-0f03-11ea-92a0-21ad272dda08.png">

<center>성적</center>
<img width="762" alt="스크린샷 2019-11-24 오후 9 46 57" src="https://user-images.githubusercontent.com/43809168/69494867-fd776400-0f03-11ea-9727-953ea81b6ba8.png">

두 테이블 모두 1차 정규화를  만족함과 동시에 2차 정규화를 만족한 상태입니다.

그러나 여전히 문제는 남아있습니다.

**삽입 이상**
새로운 학부가 생기는 경우 학생이 없다면 학번 속성이 NULL이되고 삽입할 수 없습니다.

**갱신 이상**
컴퓨터 공학과의 등록금이 변경되는 경우 모든 컴퓨터 공학과 학생들의 등록금을 변경해주어야 한다. 만약 둘다 바꿔주지않으면 데이터 불일치 현상이 일어납니다.

**삭제 이상**
특정 학생이 자퇴를 할 경우 해당 학과에 대한 정보 또한 함께 사라진집니다.

2차 정규화에서 이러한 현상이 발생하는 이유는 이행적 함수 종속성 때문입니다.

## 3차 정규화 (3NF, Third Normal Form)

``` 2차 정규화를 만족함과 동시에 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속성이 발생하지 않음을 만족하는 형태```

**이행적 함수 종속성이란?**
간단하게 설명해서 X->Y, Y->Z일때 X->Z이고 이때 Z는 X에 이행적 함수 종속되었다고 말합니다.

학생 테이블의 함수 종속성을 살펴봅시다.
```
학번 -> 학부
학부 -> 등록금
학번 -> 등록금
```

학번으로 학부를 알 수 있는 것은 맞는데,
학번으로 등록금을 아는 것은 뭔가 이상합니다.

```
X->Y, Y->Z 함수적 종속 관계로 인해 X->Z의 이행적 함수 종속성이 발생하면
[X,Y] [Y,Z]로 테이블을 나누어 준다.
```

위의 정의에 따라 3차 정규화를 진행해 봅시다.

<img width="582" alt="스크린샷 2019-11-24 오후 9 47 04" src="https://user-images.githubusercontent.com/43809168/69494868-fd776400-0f03-11ea-980a-88bc326f94ce.png">

일반적으로 3차 정규화가 진행되면 정규화가 되었다고 표현합니다.

BCNF나 그 이후의 정규화 과정이 있긴 하지만, 필자는 여기서 3차 정규화까지 다루도록 하겠습니다.


## Reference

[https://beansberries.tistory.com/entry/데이터-종속성과-정규화](https://beansberries.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A2%85%EC%86%8D%EC%84%B1%EA%B3%BC-%EC%A0%95%EA%B7%9C%ED%99%94)

[https://3months.tistory.com/193](https://3months.tistory.com/193)

[https://yaboong.github.io/database/2018/03/09/database-normalization-1/](https://yaboong.github.io/database/2018/03/09/database-normalization-1/)
